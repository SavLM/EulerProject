#include "EulerSolutions.h"
#include <iostream>
#include <vector>
#include <math.h>

int EulerSolution::MultiplesOf3And5(int input) {
	// If we list all the natural numbers below 10 that are multiples of 3 or 5,
	// we get 3, 5, 6 and 9. The sum of these multiples is 23.
	// Find the sum of all the multiples of 3 or 5 below 1000.

	int inc3 = 1;
	int inc5 = 1;
	int sum = 0;
	int c5 = 1;
	while (inc3 < input || inc5 < input) {
		if ((inc3 < input) && (inc3 % 3 == 0) && (inc3 % 5 != 0)){
			sum += inc3;
			inc3 += 3;
			if (inc3%5 == 0) inc3 += 3;
		}
		else inc3 ++;

		if ((inc5 < input) && (inc5 % 5 == 0)){
			sum += inc5;
			inc5 += 5;
		}
		else inc5++;
	}
	return sum;
}

int EulerSolution::EvenFibonacciNumbers(int input) {
	// Each new term in the Fibonacci sequence is generated by adding the previous two terms.
	// By starting with 1 and 2, the first 10 terms will be :
		// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
	// By considering the terms in the Fibonacci sequence whose values do not exceed four million,
	// find the sum of the even - valued terms.
	int a = 1;
	int b = 1;
	int c = 2;
	int sum = 2;

	while (c <= input) {
		a = b; // 1
		b = c; // 2
		c = a + b; // 3
		a = b; // 2
		b = c; // 3
		c = a + b; // 5
		a = b; // 3
		b = c; // 5
		c = a + b; // 8
		if(c<= input) sum += c;
	}
	return sum;
}

bool isPrime(long long input) {
	if (input < 4) return true;
	if (input % 2 == 0) return false;
	long long  i = 5;
	while (i < input) {
		if (input % i == 0) return false;
		i += 2;
	}
	return true;
}

long long EulerSolution::LargestPrimeFactor(long long input) {
	// The prime factors of 13195 are 5, 7, 13 and 29.
	// What is the largest prime factor of the number 600851475143?
	long long i = 1;
	while (i <= ceil(input/2)) {
		if ((input % i == 0) && isPrime(input/i)) return input/i;
		i++;
	}
	return 1;
}

bool isPalindrome(int input) {
	if (input < 10) return true;
	int temp = 1;
	int dig = 1;
	while (input / temp >= 10) {
		temp *= 10;
		dig++;
	}
	int i = dig;
	int a = 0;
	int z = 0;
	while (i >= (dig/2)) {
		// first digit
		int a1 = input / (int)pow(10, i - 1);
		int a2 = 10 * (input / (int)pow(10, i));
		a = a1 - a2;
		// last digit
		int z1 = input / (int)pow(10, dig - i);
		int z2 = 10 * (input / (int)pow(10, dig - i+1));
		z = z1 - z2;
		if (a != z) return false;
		i--;
	}
	// printf("%i is  Palindrome\n", input);
	return true;
}

int EulerSolution::LargestPalindromeProduct(int input) {
	// A palindromic number reads the same both ways.The largest palindrome made from the product of two 2 - digit numbers is 9009 = 91 × 99.
	// Find the largest palindrome made from the product of two 3 - digit numbers.
	unsigned int ret;
	unsigned int n1 = input;
	unsigned int n2 = input;
	unsigned int sub2 = 0;
	unsigned int tempPal = 0;
	bool ready = false;
	int tempn = 0;
	int temp = 1;
	while ((input * input) / temp >= 10) {
		temp *= 10;
	}
	while (n1 > 99) {
		while ((n2 > 99) && (n2 >= input - sub2)) {
			// printf("tempPal: %i, tempn: %i, mustbelessthan: %i, n1: %i, n2: %i, n1*n2: %i\n", tempPal, tempn, (tempPal - (temp)), n1, n2, n1*n2);
			if (isPalindrome(n1 * n2) && ((n1 * n2) > tempPal)) {
				tempPal = n1 * n2;
				ready = true;
			}
			tempn = n1 * n2;
			n2--;
		}
		if (tempPal > 0 && tempn <= (tempPal - temp)) return tempPal;
		n1--;
		sub2++;
		n2 = input;
	}
	return 0;
}

int EulerSolution::LargestPalindromeProduct2(int input) { // this is the slower solution to prove I wasn't crazy making the first one so complicated
	// A palindromic number reads the same both ways.The largest palindrome made from the product of two 2 - digit numbers is 9009 = 91 × 99.
	// Find the largest palindrome made from the product of two 3 - digit numbers.
	unsigned int ret;
	unsigned int checki = input;
	unsigned int checkj = input;
	unsigned int tempPal = 0; 
	int temp = 1;
	while (input / temp >= 10) {
		temp *= 10;
	}
	for (int i = input; i > 99; i--) {
		for (int j = input; j > 99; j--) {
			// printf("tempPal: %i, checki: %i, checkj: %i, i: %i, j: %i, i*j: %i\n", tempPal, checki, checkj, i, j, i*j);
			if (isPalindrome(i * j) && ((i * j) > tempPal)) {
				tempPal = i * j;
				checki = i - temp;
				checkj = j;
			}
			else if ((tempPal > 0) && (checki == i) && (checkj == j)) return tempPal;
		}
	}
	return 0;
}